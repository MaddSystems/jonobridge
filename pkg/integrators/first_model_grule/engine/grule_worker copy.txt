package engine

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"runtime"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/jonobridge/grule-integrator/actions"
	"github.com/jonobridge/grule-integrator/engine/audit"

	"github.com/MaddSystems/jonobridge/common/models"
	"github.com/hyperjumptech/grule-rule-engine/ast"
	"github.com/hyperjumptech/grule-rule-engine/engine"
)

// getGoroutineID retorna el ID de la goroutine actual para debugging
func getGoroutineID() string {
	b := make([]byte, 64)
	runtime.Stack(b, false)
	var id string
	fmt.Sscanf(string(b), "goroutine %s", &id)
	return id
}

var knowledgeBases atomic.Value // []*ast.KnowledgeBase
var noRulesLogged bool = false
var noRulesMutex sync.Mutex

// WorkerPool gestiona un worker goroutine por IMEI
type WorkerPool struct {
	workers map[string]chan *models.JonoModel // IMEI -> channel
	mu      sync.RWMutex
	kbs     []*ast.KnowledgeBase
}

var workerPool *WorkerPool

// InitializeWorkerPool inicializa el pool de workers
func InitializeWorkerPool(kbs []*ast.KnowledgeBase) {
	workerPool = &WorkerPool{
		workers: make(map[string]chan *models.JonoModel),
		kbs:     kbs,
	}
	log.Println("‚úÖ WorkerPool inicializado")
}

// getOrCreateWorker obtiene o crea un worker para un IMEI espec√≠fico
func (wp *WorkerPool) getOrCreateWorker(imei string) chan *models.JonoModel {
	wp.mu.Lock()
	defer wp.mu.Unlock()

	if ch, exists := wp.workers[imei]; exists {
		return ch
	}

	// Crear nuevo channel y worker goroutine para este IMEI
	ch := make(chan *models.JonoModel, 10) // Buffer de 10 mensajes
	wp.workers[imei] = ch

	// Lanzar worker goroutine que procesa secuencialmente los paquetes de este IMEI
	go wp.workerRoutine(imei, ch)

	log.Printf("üÜï Nuevo worker creado para IMEI: %s", imei)
	return ch
}

// workerRoutine procesa secuencialmente todos los mensajes para un IMEI
func (wp *WorkerPool) workerRoutine(imei string, ch chan *models.JonoModel) {
	gID := getGoroutineID()
	for jono := range ch {
		log.Printf("[GID:%s] üîÑ Worker procesando %d paquetes para IMEI: %s", gID, len(jono.ListPackets), imei)

		// Procesar cada paquete secuencialmente (dentro del mismo IMEI)
		for packetKey, packet := range jono.ListPackets {
			// COPIAR EL PACKET COMPLETO POR VALOR PARA EVITAR RACE CONDITIONS
			// Esto garantiza que todos los valores sean independientes de futuras mutaciones
			localPacket := packet // Copia por valor del DataPacket completo
			localPacketKey := packetKey
			localIMEI := imei

			log.Printf("[GID:%s] üîç [PACKET KEY CRUDO] IMEI=%s, Key=%s - Datetime directo: %v (IsZero=%v)",
				gID, localIMEI, localPacketKey, localPacket.Datetime, localPacket.Datetime.IsZero())

			// Usar velocidad directamente (el tracker ya env√≠a km/h)
			speedKmH := int64(localPacket.Speed)

			log.Printf("[GID:%s] üì¶ Procesando IMEI %s - Paquete: %s (Velocidad: %d, Lat: %.6f, Lon: %.6f)",
				gID, localIMEI, localPacketKey, speedKmH, localPacket.Latitude, localPacket.Longitude)
			log.Printf("[GID:%s] üïê [JSON PARSE] packet.Datetime = %v (IsZero=%v)", gID, localPacket.Datetime, localPacket.Datetime.IsZero())

			// VALIDACI√ìN TEMPRANA: Verificar si la trama es inv√°lida antes de procesarla
			// Nos saltamos tramas inv√°lidas (cuando datetime no viene del tracker o est√° corrupto)
			// Esto evita procesamiento innecesario y contaminaci√≥n de datos en las reglas
			if localPacket.Datetime.IsZero() {
				log.Printf("[GID:%s] ‚ö†Ô∏è  [TRAMA INV√ÅLIDA] Datetime=0001-01-01 para IMEI: %s - OMITIENDO REGLAS Y GUARDADO", gID, localIMEI)
				LogInvalidPacket(localIMEI)
				continue // Skip esta trama completamente: no ejecutar reglas ni guardar como procesada
			}

			log.Printf("[GID:%s] ‚úÖ [TRAMA V√ÅLIDA] Datetime=%v para IMEI: %s - PROCESANDO REGLAS", gID, localPacket.Datetime, localIMEI)

			// Desreferenciar GSMSignalStrength de forma segura
			var gsmSignalStrength int
			if localPacket.GSMSignalStrength != nil {
				gsmSignalStrength = *localPacket.GSMSignalStrength
			}

			// Calcular CurrentlyInvalid (r√©plica isValid GPSgate l√≠nea 82)
			currentlyInvalid := (localPacket.PositioningStatus != "true" && localPacket.PositioningStatus != "A")

			// Crear wrapper con VALORES LOCALES CAPTURADOS (data read-only)
			wrapper := &PacketWrapper{
				CurrentPacket:      localPacket,
				PacketKey:          localPacketKey,
				IMEI:               localIMEI,
				Speed:              speedKmH,
				Latitude:           localPacket.Latitude,
				Longitude:          localPacket.Longitude,
				Altitude:           int64(localPacket.Altitude),
				EventCode:          localPacket.EventCode,
				Datetime:           localPacket.Datetime,
				Direction:          int64(localPacket.Direction),
				Mileage:            int64(localPacket.Mileage),
				GSMSignalStrength:  int64(gsmSignalStrength),
				PositioningStatus:  localPacket.PositioningStatus,
				HDOP:               localPacket.HDOP,
				NumberOfSatellites: int64(localPacket.NumberOfSatellites),
				// Initialize execution flags to false
				DebugProcessed: true,
				ResetProcessed: false,
				Cond1Processed: false,
				Cond2Processed: false,
				Cond3Processed: false,
				Cond4Processed: false,
				Cond5Processed: false,
				// Initialize results to false
				Cond1Passed:    false,
				Cond1Failed:    false,
				Cond2Passed:    false,
				Cond2Failed:    false,
				Cond3Passed:    false,
				Cond3Failed:    false,
				Cond4Passed:    false,
				Cond4Failed:    false,
				Cond5Passed:    false,
				Cond5Failed:    false,
				HistoryUpdated: false,
				// Nuevos flags para memory buffer
				CurrentlyInvalid:  currentlyInvalid,
				BufferUpdated:     false,
				BufferHas10:       false,
				MetricsReady:      false,
				EvaluationSkipped: false,
				AlertFired:        false,
			}
			log.Printf("[GID:%s] üïê [WRAPPER] wrapper.Datetime = %v (IsZero=%v)", gID, wrapper.Datetime, wrapper.Datetime.IsZero())

			// Obtener reglas desde atomic.Value global si wp.kbs est√° vac√≠o
			kbs := wp.kbs
			if len(kbs) == 0 {
				globalKbs := knowledgeBases.Load()
				if globalKbs != nil {
					if kbsSlice, ok := globalKbs.([]*ast.KnowledgeBase); ok {
						kbs = kbsSlice
						log.Printf("[GID:%s] ‚úÖ Reglas obtenidas desde atomic.Value: %d knowledge bases", gID, len(kbs))
					}
				}

				if len(kbs) == 0 {
					log.Printf("[GID:%s] ‚ùå No hay reglas cargadas - abortando ejecuci√≥n para IMEI %s", gID, localIMEI)
					continue
				}
			}

			// Ejecutar reglas (sincr√≥nico dentro del worker)
			executeRulesForPacket(wrapper, localPacketKey, kbs, gID)

			// Guardar como procesada (ya sabemos que la trama es v√°lida por validaci√≥n temprana)
			log.Printf("[GID:%s] üíæ [SAVE PROCESSED] Guardando trama v√°lida: IMEI=%s, Key=%s, Datetime=%v", gID, localIMEI, localPacketKey, localPacket.Datetime)
			SaveProcessedFactWithContext(localIMEI, localPacketKey, localPacket.Datetime, jono)
		}

		log.Printf("[GID:%s] ‚úÖ Worker finaliz√≥ todos los paquetes para IMEI: %s", gID, imei)
	}
}

// SendToWorker env√≠a un mensaje JonoModel al worker del IMEI correspondiente
func SendToWorker(jono *models.JonoModel) {
	if workerPool == nil {
		log.Println("‚ùå WorkerPool no inicializado")
		return
	}

	ch := workerPool.getOrCreateWorker(jono.IMEI)
	select {
	case ch <- jono:
		log.Printf("üì§ Mensaje enviado al worker para IMEI: %s", jono.IMEI)
	case <-time.After(5 * time.Second):
		log.Printf("‚ö†Ô∏è  Timeout enviando mensaje al worker para IMEI: %s", jono.IMEI)
	}
}

// ProcessedFact almacena hechos ya procesados para evitar duplicados
type ProcessedFact struct {
	IMEI      string
	PacketKey string
	RuleHash  string
	Timestamp time.Time
}

// PacketWrapper envuelve los datos del packet actual de forma READ-ONLY
// Contiene SOLO datos de entrada del paquete, sin estado mutable
// TODO TODO estado mutable (como Cond1Passed) debe vivir en Property con sincronizaci√≥n
type PacketWrapper struct {
	// INPUT DATA (read-only)
	CurrentPacket      models.DataPacket
	PacketKey          string
	IMEI               string
	Speed              int64
	Latitude           float64
	Longitude          float64
	Altitude           int64
	EventCode          models.EventCode
	Datetime           time.Time
	Direction          int64
	Mileage            int64
	GSMSignalStrength  int64
	PositioningStatus  string
	HDOP               float64
	NumberOfSatellites int64

	// EXECUTION FLAGS (accessible from rules for control flow)
	// These mirror Property state for rule engine access
	DebugProcessed bool
	ResetProcessed bool
	Cond1Processed bool
	Cond2Processed bool
	Cond3Processed bool
	Cond4Processed bool
	Cond5Processed bool

	// EXECUTION RESULTS (from old working rules)
	Cond1Passed    bool
	Cond1Failed    bool
	Cond2Passed    bool
	Cond2Failed    bool
	Cond3Passed    bool
	Cond3Failed    bool
	Cond4Passed    bool
	Cond4Failed    bool
	Cond5Passed    bool
	Cond5Failed    bool
	HistoryUpdated bool

	// NUEVOS FLAGS para sistema de memory buffer (GPSgate)
	BufferUpdated     bool `json:"bufferUpdated"`     // Buffer actualizado SIEMPRE
	BufferHas10       bool `json:"bufferHas10"`       // Buffer tiene 10 (doit)
	MetricsReady      bool `json:"metricsReady"`      // M√©tricas calculadas
	CurrentlyInvalid  bool `json:"currentlyInvalid"`  // Posici√≥n actual inv√°lida
	EvaluationSkipped bool `json:"evaluationSkipped"` // Evaluaci√≥n omitida
	AlertFired        bool `json:"alertFired"`        // Alerta disparada
	IsOfflineFor5Min  bool `json:"isOfflineFor5Min"`  // Flag offline > 5 min (pre-calculado)

	// Funciones helper para acceso desde las reglas
	GetSpeed     func() int64
	GetLatitude  func() float64
	GetLongitude func() float64
	GetAltitude  func() int64
	GetEventCode func() models.EventCode
}

// ActionsHelper expone las funciones de acciones para que Grule pueda llamarlas
type ActionsHelper struct{}

// SendTelegram es un m√©todo que Grule puede llamar como actions.SendTelegram()
func (a *ActionsHelper) SendTelegram(message string) {
	actions.SendTelegram(message)
}

// SendEmail es un m√©todo que Grule puede llamar como actions.SendEmail()
func (a *ActionsHelper) SendEmail(subject, body string) {
	actions.SendEmail(subject, body)
}

// CutEngine es un m√©todo que Grule puede llamar como actions.CutEngine()
func (a *ActionsHelper) CutEngine(imei string) {
	actions.CutEngine(imei)
}

// Log es un m√©todo que Grule puede llamar como actions.Log()
func (a *ActionsHelper) Log(msg string, args ...interface{}) {
	log.Printf(msg, args...)
}

// ProcessJonoMessage desempaqueta JSON y env√≠a al worker correspondiente
func ProcessJonoMessage(payload string) {
	// MySQL 8.0.44 Fix: Pre-validar campos datetime antes del parsing JSON

	var jono models.JonoModel
	if err := json.Unmarshal([]byte(payload), &jono); err != nil {
		// Intentar extraer IMEI del payload JSON crudo para debugging
		var rawData map[string]interface{}
		imeiStr := "UNKNOWN"
		hasListPackets := false
		datetimeValue := ""

		if json.Unmarshal([]byte(payload), &rawData) == nil {
			if imei, ok := rawData["IMEI"].(string); ok {
				imeiStr = imei
			}

			// Verificar si ListPackets existe y est√° poblado
			if listPackets, ok := rawData["ListPackets"].(map[string]interface{}); ok && len(listPackets) > 0 {
				hasListPackets = true

				// Intentar extraer el Datetime del primer paquete para debugging
				for key, packet := range listPackets {
					if packetMap, ok := packet.(map[string]interface{}); ok {
						if dt, exists := packetMap["Datetime"]; exists {
							datetimeValue = fmt.Sprintf("%v", dt)
							log.Printf("üîç IMEI %s - Packet %s: Datetime='%s' (empty=%v)", imeiStr, key, datetimeValue, datetimeValue == "")
						}
						break // Solo revisar el primer paquete
					}
				}
			}
		}

		if hasListPackets {
			log.Printf("‚ùå IMEI %s: Error parsing JSON - ListPackets existe pero tiene campos inv√°lidos (ej: Datetime vac√≠o o formato incorrecto). Error: %v", imeiStr, err)
		} else {
			log.Printf("‚ùå IMEI %s: Error parsing JSON - ListPackets no existe o est√° vac√≠o. El int√©rprete NO proces√≥ esta trama. Error: %v", imeiStr, err)
		}
		return
	}

	if len(jono.ListPackets) == 0 {
		log.Printf("‚ö†Ô∏è  IMEI %s sin paquetes de datos", jono.IMEI)
		return
	}

	// Validar que haya reglas cargadas
	kbs := knowledgeBases.Load().([]*ast.KnowledgeBase)
	if len(kbs) == 0 {
		// Log una sola vez que no hay reglas cargadas
		noRulesMutex.Lock()
		if !noRulesLogged {
			log.Printf("‚ö†Ô∏è  No hay reglas cargadas en el motor Grule")
			noRulesLogged = true
		}
		noRulesMutex.Unlock()
		return
	}

	// Enviar al worker del IMEI (no ejecutar directamente)
	SendToWorker(&jono)
} // executeRulesForPacket ejecuta las reglas para un paquete espec√≠fico
func executeRulesForPacket(wrapper *PacketWrapper, packetKey string, kbs []*ast.KnowledgeBase, gID string) {
	log.Printf("[GID:%s] üöÄ Iniciando ejecuci√≥n de reglas para paquete %s (IMEI: %s)", gID, packetKey, wrapper.IMEI)

	// üÜï NUEVO SISTEMA: Iniciar captura de auditor√≠a ANTES de ejecutar reglas
	audit.StartCapture(wrapper.IMEI)
	defer audit.FinishCapture(wrapper.IMEI) // Guardar al finalizar

	dataCtx := ast.NewDataContext()
	dataCtx.Add("Jono", wrapper)

	// Crear Property con sincronizaci√≥n via channels
	property := NewProperty(gID, context.Background())
	defer property.Close()

	log.Printf("[GID:%s] üìã Property creado para sincronizaci√≥n de eventos", gID)

	state := NewPersistentState(wrapper.IMEI)
	dataCtx.Add("state", state)
	dataCtx.Add("property", property)

	// üÜï NUEVO SISTEMA: ActionsHelper con snapshot completo del contexto para Audit()
	actionsObj := &actions.ActionsHelper{
		IMEI:              wrapper.IMEI,
		Speed:             wrapper.Speed,
		Latitude:          wrapper.Latitude,
		Longitude:         wrapper.Longitude,
		Altitude:          wrapper.Altitude,
		GSMSignalStrength: wrapper.GSMSignalStrength,
		Satellites:        wrapper.NumberOfSatellites,
		PositioningStatus: wrapper.PositioningStatus,
		EventCode:         wrapper.EventCode.Name,
		Datetime:          wrapper.Datetime,
	}
	dataCtx.Add("actions", actionsObj)

	eng := engine.NewGruleEngine()
	eng.MaxCycle = 100 // Reducir ciclos m√°ximos para detectar ciclos infinitos r√°pidamente

	// üéØ CAPTURAR TODAS las reglas del knowledge base (sin evaluar condiciones)
	// Las condiciones no se cumplen antes de Execute(), as√≠ que capturamos TODAS
	allRulesMap := make(map[string]int) // ruleName -> salience
	for _, kb := range kbs {
		for ruleName, ruleEntry := range kb.RuleEntries {
			allRulesMap[ruleName] = ruleEntry.Salience
			log.Printf("[GID:%s] üéØ Regla registrada para auditor√≠a: %s (salience=%d)", gID, ruleName, ruleEntry.Salience)
		}
	}

	for i, kb := range kbs {
		log.Printf("[GID:%s] üìã Ejecutando knowledge base %d/%d con %d reglas", gID, i+1, len(kbs), len(kb.RuleEntries))

		// üîç DEBUG: Log contexto inicial antes de ejecutar reglas
		log.Printf("[GID:%s] üîç DEBUG: Contexto inicial para %s: BufferUpdated=%v, CurrentlyInvalid=%v, Cond1Passed=%v, Cond2Passed=%v, Cond3Passed=%v, IsOfflineFor5Min=%v",
			gID, packetKey, wrapper.BufferUpdated, wrapper.CurrentlyInvalid, wrapper.Cond1Passed, wrapper.Cond2Passed, wrapper.Cond3Passed, wrapper.IsOfflineFor5Min)

		err := eng.Execute(dataCtx, kb)
		if err != nil {
			log.Printf("[GID:%s] ‚ö†Ô∏è  ERROR en paquete %s: %v", gID, packetKey, err)
			log.Printf("[GID:%s]    Estado del contexto cuando fall√≥:", gID)
			log.Printf("[GID:%s]    - Jono.PositioningStatus: %s", gID, wrapper.PositioningStatus)
			log.Printf("[GID:%s]    - State Snapshot: %+v", gID, state.GetSnapshot())
			// üîç DEBUG: Log contexto final y reglas ejecutadas
			log.Printf("[GID:%s] üîç DEBUG: Contexto final: BufferUpdated=%v, CurrentlyInvalid=%v, Cond1Passed=%v, Cond2Passed=%v, Cond3Passed=%v, IsOfflineFor5Min=%v",
				gID, wrapper.BufferUpdated, wrapper.CurrentlyInvalid, wrapper.Cond1Passed, wrapper.Cond2Passed, wrapper.Cond3Passed, wrapper.IsOfflineFor5Min)
			log.Printf("[GID:%s] üîç DEBUG: Reglas registradas en KB: %v", gID, allRulesMap)
		} else {
			log.Printf("[GID:%s] ‚úÖ Knowledge base %d ejecutada sin errores", gID, i+1)

			// üîÑ SYNC: Actualizar wrapper flags desde Property state
			wrapper.DebugProcessed = property.GetDebugProcessed()
			wrapper.ResetProcessed = property.GetResetProcessed()
			wrapper.Cond1Processed = property.GetCond1Processed()
			wrapper.Cond2Processed = property.GetCond2Processed()
			wrapper.Cond3Processed = property.GetCond3Processed()
			wrapper.Cond4Processed = property.GetCond4Processed()
			wrapper.Cond5Processed = property.GetCond5Processed()
			wrapper.BufferUpdated = property.GetBufferUpdated()
			wrapper.BufferHas10 = property.GetBufferHas10()
			wrapper.MetricsReady = property.GetMetricsReady()
			wrapper.CurrentlyInvalid = property.GetCurrentlyInvalid()
			wrapper.EvaluationSkipped = property.GetEvaluationSkipped()
			wrapper.AlertFired = property.GetAlertFired()

			log.Printf("[GID:%s]    Estado final del contexto:", gID)
			log.Printf("[GID:%s]    - State Snapshot: %+v", gID, state.GetSnapshot())

			// LOG DE FLAGS DESPU√âS DE EJECUTAR REGLAS - DESDE PROPERTY
			log.Printf("[GID:%s] üö® FLAGS DESPU√âS DE EJECUTAR REGLAS (desde Property):", gID)
			log.Printf("[GID:%s]    - property.Cond1Passed: %v", gID, property.GetCond1Passed())
			log.Printf("[GID:%s]    - property.Cond2Passed: %v", gID, property.GetCond2Passed())
			log.Printf("[GID:%s]    - property.Cond3Passed: %v", gID, property.GetCond3Passed())
			log.Printf("[GID:%s]    - property.Cond4Passed: %v", gID, property.GetCond4Passed())
			log.Printf("[GID:%s]    - property.Cond5Passed: %v", gID, property.GetCond5Passed())

			// Tambi√©n loggeamos desde Jono por compatibilidad (ahora usando property)
			log.Printf("[GID:%s]    - Jono.Cond1Passed: %v (via property)", gID, property.GetCond1Passed())
			log.Printf("[GID:%s]    - Jono.Cond2Passed: %v (via property)", gID, property.GetCond2Passed())
			log.Printf("[GID:%s]    - Jono.Cond3Passed: %v (via property)", gID, property.GetCond3Passed())
			log.Printf("[GID:%s]    - Jono.Cond4Passed: %v (via property)", gID, property.GetCond4Passed())
			log.Printf("[GID:%s]    - Jono.Cond5Passed: %v (via property)", gID, property.GetCond5Passed())

			log.Printf("[GID:%s]    - state.Cond2Checked: %v", gID, state.GetCond2Checked())
			log.Printf("[GID:%s]    - state.Cond3Checked: %v", gID, state.GetCond3Checked())
			log.Printf("[GID:%s]    - state.Cond4Checked: %v", gID, state.GetCond4Checked())
		}
	}

	// üÜï NUEVO SISTEMA: La auditor√≠a se guarda autom√°ticamente en defer audit.FinishCapture()

	// üé¨ CAPTURAR "FRAMES DE PEL√çCULA" con buffer circular y contexto completo
	captureMovieFrames(wrapper.IMEI, wrapper, state, gID, allRulesMap)

	log.Printf("[GID:%s] üèÅ Finalizada ejecuci√≥n de reglas para paquete %s", gID, packetKey)
}

// captureMovieFrames captura el estado completo como "frames de pel√≠cula"
// Muestra la evoluci√≥n: buffer circular, m√©tricas, geofences, flags
// AHORA: 1 frame por ejecuci√≥n de KB, con componentes ejecutados
func captureMovieFrames(imei string, wrapper *PacketWrapper, state *PersistentState, gID string, allRules map[string]int) {
	// MODIFICACI√ìN: Guardar frame SIEMPRE para capturar progreso de steps
	// Aunque no se ejecuten reglas nuevas, el step calculado puede haber cambiado

	// Obtener buffer circular completo
	bufferEntries := GetBufferEntries(imei)

	// Construir snapshot del contexto completo
	contextSnapshot := map[string]interface{}{
		"buffer_circular": bufferEntries, // "Cuadritos de la pel√≠cula" - historial de posiciones
		"state_metrics":   state.GetSnapshot(),
		"geofence_checks": map[string]bool{
			"inside_taller":    state.IsInsideGroup("Taller", wrapper.Latitude, wrapper.Longitude),
			"inside_clientes":  state.IsInsideGroup("CLIENTES", wrapper.Latitude, wrapper.Longitude),
			"inside_resguardo": state.IsInsideGroup("Resguardo/Cedis/Puerto", wrapper.Latitude, wrapper.Longitude),
			"offline_5min":     state.IsOfflineFor(5),
		},
		"wrapper_flags": map[string]bool{
			"BufferUpdated":     wrapper.BufferUpdated,
			"BufferHas10":       wrapper.BufferHas10,
			"MetricsReady":      wrapper.MetricsReady,
			"CurrentlyInvalid":  wrapper.CurrentlyInvalid,
			"EvaluationSkipped": wrapper.EvaluationSkipped,
			"AlertFired":        wrapper.AlertFired,
			"Cond1Passed":       wrapper.Cond1Passed,
			"Cond2Passed":       wrapper.Cond2Passed,
			"Cond3Passed":       wrapper.Cond3Passed,
			"Cond4Passed":       wrapper.Cond4Passed,
			"Cond5Passed":       wrapper.Cond5Passed,
			"IsOfflineFor5Min":  state.IsOfflineFor(5), // Check logic directly for snapshot
		},
		"packet_current": map[string]interface{}{
			"Speed":             wrapper.Speed,
			"Latitude":          wrapper.Latitude,
			"Longitude":         wrapper.Longitude,
			"Altitude":          wrapper.Altitude,
			"GSMSignalStrength": wrapper.GSMSignalStrength,
			"Satellites":        wrapper.NumberOfSatellites,
			"PositioningStatus": wrapper.PositioningStatus,
			"Datetime":          wrapper.Datetime,
			"EventCode":         wrapper.EventCode,
		},
	}

	// Detectar componentes ejecutados bas√°ndose en flags del wrapper
	componentsExecuted := detectExecutedComponents(wrapper)
	componentDetails := map[string]interface{}{
		"buffer_updated":     wrapper.BufferUpdated,
		"buffer_size":        len(bufferEntries),
		"metrics_calculated": wrapper.MetricsReady,
		"evaluation_skipped": wrapper.EvaluationSkipped,
		"alert_triggered":    wrapper.AlertFired,
	}

	// Determinar el paso m√°ximo alcanzado (Mapping DEFCON 0-4)
	// DEFCON 0: Surveillance (Buffering & Normal State)
	// DEFCON 1: Tracker Contact is Lost (Offline > 5 min)
	// DEFCON 2: Inhibition Detected (High Speed + Signal -> No GPS)
	// DEFCON 3: Outside Safe Zones
	// DEFCON 4: Jammer Detected (Action)

	step := 0
	stage := "Surveillance (Buffering & Normal State)" // DEFCON 0
	reason := "Monitoring"

	if wrapper.AlertFired {
		// DEFCON 4: Alert fired in this packet
		step = 4
		stage = "Jammer Detected"
		reason = "Alert Fired"
	} else if state.GetCounter("jammer_avg_speed_90min") > 0 {
		// DEFCON 2+: Metrics calculated (persistent state)
		speed90 := state.GetCounter("jammer_avg_speed_90min")
		gsm5 := state.GetCounter("jammer_avg_gsm_last5")

		if speed90 >= 10 && gsm5 >= 9 {
			// Passed DEFCON 2 -> Check DEFCON 3 (Geofences)
			if !state.IsInsideGroup("Taller", wrapper.Latitude, wrapper.Longitude) &&
				!state.IsInsideGroup("CLIENTES", wrapper.Latitude, wrapper.Longitude) &&
				!state.IsInsideGroup("Resguardo/Cedis/Puerto", wrapper.Latitude, wrapper.Longitude) {
				// Passed DEFCON 3
				step = 3
				stage = "Outside Safe Zones"
				reason = "Ready to Fire"
			} else {
				// Failed DEFCON 3
				step = 3
				stage = "Outside Safe Zones"
				reason = "Inside Safe Zone"
			}
		} else {
			// Failed DEFCON 2
			step = 2
			stage = "Inhibition Detected (Failed)"
			reason = "Signature Mismatch"
		}
	} else if state.IsOfflineFor(5) && wrapper.CurrentlyInvalid && wrapper.BufferHas10 {
		// DEFCON 1: Offline > 5 min (persistent)
		step = 1
		stage = "Tracker Contact is Lost"
		reason = "Offline > 5 min"
	} else if wrapper.BufferUpdated {
		// DEFCON 0
		step = 0
		stage = "Surveillance (Buffering & Normal State)"
		if !wrapper.CurrentlyInvalid {
			reason = "Position Valid"
		} else if !wrapper.BufferHas10 {
			reason = "Filling Buffer (" + strconv.Itoa(state.GetBufferSize(wrapper.IMEI)) + "/10)"
		} else if !state.IsOfflineFor(5) {
			reason = "Waiting Offline Timer"
		} else {
			reason = "Monitoring"
		}
	}

	// Determinar evaluaci√≥n de geofence
	geofenceEval := "not_evaluated"
	if step >= 3 {
		if state.IsInsideGroup("Taller", wrapper.Latitude, wrapper.Longitude) {
			geofenceEval = "inside_taller"
		} else if state.IsInsideGroup("CLIENTES", wrapper.Latitude, wrapper.Longitude) {
			geofenceEval = "inside_clientes"
		} else if state.IsInsideGroup("Resguardo/Cedis/Puerto", wrapper.Latitude, wrapper.Longitude) {
			geofenceEval = "inside_resguardo"
		} else {
			geofenceEval = "outside_all"
		}
	}

	// CONSOLIDACI√ìN: 1 frame por ejecuci√≥n de KB
	// Seleccionar rule_name basado en el step alcanzado, no en salience m√°xima
	var ruleName string
	switch step {
	case 0:
		ruleName = "DEFCON0_Surveillance"
	case 1:
		ruleName = "DEFCON1_ContactLost_Pass"
	case 2:
		ruleName = "DEFCON2_Inhibition_Pass"
	case 3:
		ruleName = "DEFCON3_SafeZones_Pass"
	case 4:
		ruleName = "DEFCON4_JammerDetected"
	default:
		ruleName = "Unknown"
	}

	var ruleID int64
	// Obtener el ID del paquete global, no de la subregla
	ruleID = getRuleIDByName("Jammer-Wargames-DEFCON")

	log.Printf("[GID:%s] üé¨ Frame consolidado: Rule='%s' (ID=%d), Components=%v, Step=%d, Stage=%s, Reason=%s, Buffer=%d/10",
		gID, ruleName, ruleID, componentsExecuted, step, stage, reason, len(bufferEntries))

	// Guardar UN SOLO frame consolidado
	err := audit.SaveProgressFrame(imei, ruleID, ruleName, componentsExecuted, componentDetails,
		step, stage, reason, len(bufferEntries), wrapper.MetricsReady, geofenceEval, contextSnapshot)

	if err != nil {
		log.Printf("[GID:%s] ‚ö†Ô∏è Error guardando frame consolidado: %v", gID, err)
	} else {
		log.Printf("[GID:%s]    ‚úÖ Frame consolidado guardado en DB", gID)
	}
}

// detectExecutedComponents determina qu√© componentes l√≥gicos se ejecutaron bas√°ndose en flags
func detectExecutedComponents(wrapper *PacketWrapper) []string {
	var components []string

	// Componente 1: BufferUpdate - se ejecuta si BufferUpdated
	if wrapper.BufferUpdated {
		components = append(components, "BufferUpdate")
	}

	// Componente 2: CalculateMetrics - se ejecuta si MetricsReady (porque se calculan m√©tricas)
	if wrapper.MetricsReady {
		components = append(components, "CalculateMetrics")
	}

	// Componente 3: Detection - se ejecuta si AlertFired
	if wrapper.AlertFired {
		components = append(components, "Detection")
	}

	// Componente 4: SkipIfValid - se ejecuta si EvaluationSkipped
	if wrapper.EvaluationSkipped {
		components = append(components, "SkipIfValid")
	}

	return components
}

// getRuleIDByName obtiene el ID de una regla desde fleet_rules por nombre
func getRuleIDByName(ruleName string) int64 {
	return GetRuleIDByName(ruleName)
}

// Convierte strings vac√≠os "" a null en campos datetime para evitar parsing errors
