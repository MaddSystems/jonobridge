package engine

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"runtime"
	"sync"
	"sync/atomic"
	"time"

	"github.com/jonobridge/grule-integrator/actions"
	"github.com/jonobridge/grule-integrator/engine/audit"

	"github.com/MaddSystems/jonobridge/common/models"
	"github.com/hyperjumptech/grule-rule-engine/ast"
	"github.com/hyperjumptech/grule-rule-engine/engine"
)

// getGoroutineID retorna el ID de la goroutine actual para debugging
func getGoroutineID() string {
	b := make([]byte, 64)
	runtime.Stack(b, false)
	var id string
	fmt.Sscanf(string(b), "goroutine %s", &id)
	return id
}

var knowledgeBases atomic.Value // []*ast.KnowledgeBase
var noRulesLogged bool = false
var noRulesMutex sync.Mutex

// WorkerPool gestiona un worker goroutine por IMEI
type WorkerPool struct {
	workers map[string]chan *models.JonoModel // IMEI -> channel
	mu      sync.RWMutex
	kbs     []*ast.KnowledgeBase
}

var workerPool *WorkerPool

// InitializeWorkerPool inicializa el pool de workers
func InitializeWorkerPool(kbs []*ast.KnowledgeBase) {
	workerPool = &WorkerPool{
		workers: make(map[string]chan *models.JonoModel),
		kbs:     kbs,
	}
	log.Println("‚úÖ WorkerPool inicializado")
}

// getOrCreateWorker obtiene o crea un worker para un IMEI espec√≠fico
func (wp *WorkerPool) getOrCreateWorker(imei string) chan *models.JonoModel {
	wp.mu.Lock()
	defer wp.mu.Unlock()

	if ch, exists := wp.workers[imei]; exists {
		return ch
	}

	// Crear nuevo channel y worker goroutine para este IMEI
	ch := make(chan *models.JonoModel, 10) // Buffer de 10 mensajes
	wp.workers[imei] = ch

	// Lanzar worker goroutine que procesa secuencialmente los paquetes de este IMEI
	go wp.workerRoutine(imei, ch)

	log.Printf("üÜï Nuevo worker creado para IMEI: %s", imei)
	return ch
}

// workerRoutine procesa secuencialmente todos los mensajes para un IMEI
func (wp *WorkerPool) workerRoutine(imei string, ch chan *models.JonoModel) {
	gID := getGoroutineID()
	for jono := range ch {
		log.Printf("[GID:%s] üîÑ Worker procesando %d paquetes para IMEI: %s", gID, len(jono.ListPackets), imei)

		// Procesar cada paquete secuencialmente (dentro del mismo IMEI)
		for packetKey, packet := range jono.ListPackets {
			// COPIAR EL PACKET COMPLETO POR VALOR PARA EVITAR RACE CONDITIONS
			// Esto garantiza que todos los valores sean independientes de futuras mutaciones
			localPacket := packet // Copia por valor del DataPacket completo
			localPacketKey := packetKey
			localIMEI := imei

			log.Printf("[GID:%s] üîç [PACKET KEY CRUDO] IMEI=%s, Key=%s - Datetime directo: %v (IsZero=%v)",
				gID, localIMEI, localPacketKey, localPacket.Datetime, localPacket.Datetime.IsZero())

			// Convertir velocidad de m/s a km/h
			speedKmH := int(float64(localPacket.Speed) * 3.6)

			log.Printf("[GID:%s] üì¶ Procesando IMEI %s - Paquete: %s (Velocidad: %d m/s = %d km/h, Lat: %.6f, Lon: %.6f)",
				gID, localIMEI, localPacketKey, localPacket.Speed, speedKmH, localPacket.Latitude, localPacket.Longitude)
			log.Printf("[GID:%s] üïê [JSON PARSE] packet.Datetime = %v (IsZero=%v)", gID, localPacket.Datetime, localPacket.Datetime.IsZero())

			// VALIDACI√ìN TEMPRANA: Verificar si la trama es inv√°lida antes de procesarla
			// Nos saltamos tramas inv√°lidas (cuando datetime no viene del tracker o est√° corrupto)
			// Esto evita procesamiento innecesario y contaminaci√≥n de datos en las reglas
			if localPacket.Datetime.IsZero() {
				log.Printf("[GID:%s] ‚ö†Ô∏è  [TRAMA INV√ÅLIDA] Datetime=0001-01-01 para IMEI: %s - OMITIENDO REGLAS Y GUARDADO", gID, localIMEI)
				LogInvalidPacket(localIMEI)
				continue // Skip esta trama completamente: no ejecutar reglas ni guardar como procesada
			}

			log.Printf("[GID:%s] ‚úÖ [TRAMA V√ÅLIDA] Datetime=%v para IMEI: %s - PROCESANDO REGLAS", gID, localPacket.Datetime, localIMEI)

			// Desreferenciar GSMSignalStrength de forma segura
			var gsmSignalStrength int
			if localPacket.GSMSignalStrength != nil {
				gsmSignalStrength = *localPacket.GSMSignalStrength
			}

			// Calcular CurrentlyInvalid (r√©plica isValid GPSgate l√≠nea 82)
			currentlyInvalid := (localPacket.PositioningStatus != "true" && localPacket.PositioningStatus != "A")

			// Calcular fecha de √∫ltimo contacto v√°lido
			bufferEntries := GetBufferEntries(localIMEI)
			var lastValidDatetime time.Time
			for _, entry := range bufferEntries {
				if entry.IsValid {
					if entry.Datetime.After(lastValidDatetime) {
						lastValidDatetime = entry.Datetime
					}
				}
			}

			// Crear wrapper con VALORES LOCALES CAPTURADOS (data read-only)
			wrapper := &PacketWrapper{
				CurrentPacket:      localPacket,
				PacketKey:          localPacketKey,
				IMEI:               localIMEI,
				Speed:              int64(speedKmH),
				Latitude:           localPacket.Latitude,
				Longitude:          localPacket.Longitude,
				Altitude:           int64(localPacket.Altitude),
				EventCode:          localPacket.EventCode,
				Datetime:           localPacket.Datetime,
				Direction:          int64(localPacket.Direction),
				Mileage:            int64(localPacket.Mileage),
				GSMSignalStrength:  int64(gsmSignalStrength),
				PositioningStatus:  localPacket.PositioningStatus,
				HDOP:               localPacket.HDOP,
				NumberOfSatellites: int64(localPacket.NumberOfSatellites),
				LastValidDatetime:  lastValidDatetime,
				// Initialize execution flags to false
				DebugProcessed: true,
				ResetProcessed: false,
				Cond1Processed: false,
				Cond2Processed: false,
				Cond3Processed: false,
				Cond4Processed: false,
				Cond5Processed: false,
				// Initialize results to false
				Cond1Passed:      false,
				Cond1Failed:      false,
				Cond2Passed:      false,
				Cond2Failed:      false,
				Cond3Passed:      false,
				Cond3Failed:      false,
				Cond4Passed:      false,
				Cond4Failed:      false,
				Cond5Passed:      false,
				Cond5Failed:      false,
				HistoryUpdated:   false,
				IsOfflineFor5Min: false,
				// Nuevos flags para memory buffer
				CurrentlyInvalid:  currentlyInvalid,
				BufferUpdated:     false,
				BufferHas10:       false,
				MetricsReady:      false,
				EvaluationSkipped: false,
				AlertFired:        false,
			}
			log.Printf("[GID:%s] üïê [WRAPPER] wrapper.Datetime = %v (IsZero=%v)", gID, wrapper.Datetime, wrapper.Datetime.IsZero())

			// Obtener reglas desde atomic.Value global si wp.kbs est√° vac√≠o
			kbs := wp.kbs
			if len(kbs) == 0 {
				globalKbs := knowledgeBases.Load()
				if globalKbs != nil {
					if kbsSlice, ok := globalKbs.([]*ast.KnowledgeBase); ok {
						kbs = kbsSlice
						log.Printf("[GID:%s] ‚úÖ Reglas obtenidas desde atomic.Value: %d knowledge bases", gID, len(kbs))
					}
				}

				if len(kbs) == 0 {
					log.Printf("[GID:%s] ‚ùå No hay reglas cargadas - abortando ejecuci√≥n para IMEI %s", gID, localIMEI)
					continue
				}
			}

			// Ejecutar reglas (sincr√≥nico dentro del worker)
			executeRulesForPacket(*wrapper, localPacketKey, kbs, gID)

			// Guardar como procesada (ya sabemos que la trama es v√°lida por validaci√≥n temprana)
			log.Printf("[GID:%s] üíæ [SAVE PROCESSED] Guardando trama v√°lida: IMEI=%s, Key=%s, Datetime=%v", gID, localIMEI, localPacketKey, localPacket.Datetime)
			SaveProcessedFactWithContext(localIMEI, localPacketKey, localPacket.Datetime, jono)
		}

		log.Printf("[GID:%s] ‚úÖ Worker finaliz√≥ todos los paquetes para IMEI: %s", gID, imei)
	}
}

// SendToWorker env√≠a un mensaje JonoModel al worker del IMEI correspondiente
func SendToWorker(jono *models.JonoModel) {
	if workerPool == nil {
		log.Println("‚ùå WorkerPool no inicializado")
		return
	}

	ch := workerPool.getOrCreateWorker(jono.IMEI)
	select {
	case ch <- jono:
		log.Printf("üì§ Mensaje enviado al worker para IMEI: %s", jono.IMEI)
	case <-time.After(5 * time.Second):
		log.Printf("‚ö†Ô∏è  Timeout enviando mensaje al worker para IMEI: %s", jono.IMEI)
	}
}

// ProcessedFact almacena hechos ya procesados para evitar duplicados
type ProcessedFact struct {
	IMEI      string
	PacketKey string
	RuleHash  string
	Timestamp time.Time
}

// PacketWrapper envuelve los datos del packet actual de forma READ-ONLY
// Contiene SOLO datos de entrada del paquete, sin estado mutable
// TODO TODO estado mutable (como Cond1Passed) debe vivir en Property con sincronizaci√≥n
type PacketWrapper struct {
	// INPUT DATA (read-only)
	CurrentPacket      models.DataPacket
	PacketKey          string
	IMEI               string
	Speed              int64
	Latitude           float64
	Longitude          float64
	Altitude           int64
	EventCode          models.EventCode
	Datetime           time.Time
	Direction          int64
	Mileage            int64
	GSMSignalStrength  int64
	PositioningStatus  string
	HDOP               float64
	NumberOfSatellites int64
	LastValidDatetime  time.Time // Fecha del √∫ltimo paquete v√°lido en el buffer

	// EXECUTION FLAGS (accessible from rules for control flow)
	// These mirror Property state for rule engine access
	DebugProcessed bool
	ResetProcessed bool
	Cond1Processed bool
	Cond2Processed bool
	Cond3Processed bool
	Cond4Processed bool
	Cond5Processed bool

	// EXECUTION RESULTS (from old working rules)
	Cond1Passed      bool
	Cond1Failed      bool
	Cond2Passed      bool
	Cond2Failed      bool
	Cond3Passed      bool
	Cond3Failed      bool
	Cond4Passed      bool
	Cond4Failed      bool
	Cond5Passed      bool
	Cond5Failed      bool
	HistoryUpdated   bool
	IsOfflineFor5Min bool

	// NUEVOS FLAGS para sistema de memory buffer (GPSgate)
	BufferUpdated     bool `json:"bufferUpdated"`     // Buffer actualizado SIEMPRE
	BufferHas10       bool `json:"bufferHas10"`       // Buffer tiene 10 (doit)
	MetricsReady      bool `json:"metricsReady"`      // M√©tricas calculadas
	CurrentlyInvalid  bool `json:"currentlyInvalid"`  // Posici√≥n actual inv√°lida
	EvaluationSkipped bool `json:"evaluationSkipped"` // Evaluaci√≥n omitida
	AlertFired        bool `json:"alertFired"`        // Alerta disparada

	// Funciones helper para acceso desde las reglas
	GetSpeed     func() int64
	GetLatitude  func() float64
	GetLongitude func() float64
	GetAltitude  func() int64
	GetEventCode func() models.EventCode
}

// ActionsHelper expone las funciones de acciones para que Grule pueda llamarlas
type ActionsHelper struct{}

// SendTelegram es un m√©todo que Grule puede llamar como actions.SendTelegram()
func (a *ActionsHelper) SendTelegram(message string) {
	actions.SendTelegram(message)
}

// SendEmail es un m√©todo que Grule puede llamar como actions.SendEmail()
func (a *ActionsHelper) SendEmail(subject, body string) {
	actions.SendEmail(subject, body)
}

// CutEngine es un m√©todo que Grule puede llamar como actions.CutEngine()
func (a *ActionsHelper) CutEngine(imei string) {
	actions.CutEngine(imei)
}

// Log es un m√©todo que Grule puede llamar como actions.Log()
func (a *ActionsHelper) Log(msg string, args ...interface{}) {
	log.Printf(msg, args...)
}

// ProcessJonoMessage desempaqueta JSON y env√≠a al worker correspondiente
func ProcessJonoMessage(payload string) {
	// MySQL 8.0.44 Fix: Pre-validar campos datetime antes del parsing JSON

	var jono models.JonoModel
	if err := json.Unmarshal([]byte(payload), &jono); err != nil {
		// Intentar extraer IMEI del payload JSON crudo para debugging
		var rawData map[string]interface{}
		imeiStr := "UNKNOWN"
		hasListPackets := false
		datetimeValue := ""

		if json.Unmarshal([]byte(payload), &rawData) == nil {
			if imei, ok := rawData["IMEI"].(string); ok {
				imeiStr = imei
			}

			// Verificar si ListPackets existe y est√° poblado
			if listPackets, ok := rawData["ListPackets"].(map[string]interface{}); ok && len(listPackets) > 0 {
				hasListPackets = true

				// Intentar extraer el Datetime del primer paquete para debugging
				for key, packet := range listPackets {
					if packetMap, ok := packet.(map[string]interface{}); ok {
						if dt, exists := packetMap["Datetime"]; exists {
							datetimeValue = fmt.Sprintf("%v", dt)
							log.Printf("üîç IMEI %s - Packet %s: Datetime='%s' (empty=%v)", imeiStr, key, datetimeValue, datetimeValue == "")
						}
						break // Solo revisar el primer paquete
					}
				}
			}
		}

		if hasListPackets {
			log.Printf("‚ùå IMEI %s: Error parsing JSON - ListPackets existe pero tiene campos inv√°lidos (ej: Datetime vac√≠o o formato incorrecto). Error: %v", imeiStr, err)
		} else {
			log.Printf("‚ùå IMEI %s: Error parsing JSON - ListPackets no existe o est√° vac√≠o. El int√©rprete NO proces√≥ esta trama. Error: %v", imeiStr, err)
		}
		return
	}

	if len(jono.ListPackets) == 0 {
		log.Printf("‚ö†Ô∏è  IMEI %s sin paquetes de datos", jono.IMEI)
		return
	}

	// Validar que haya reglas cargadas
	kbs := knowledgeBases.Load().([]*ast.KnowledgeBase)
	if len(kbs) == 0 {
		// Log una sola vez que no hay reglas cargadas
		noRulesMutex.Lock()
		if !noRulesLogged {
			log.Printf("‚ö†Ô∏è  No hay reglas cargadas en el motor Grule")
			noRulesLogged = true
		}
		noRulesMutex.Unlock()
		return
	}

	// Enviar al worker del IMEI (no ejecutar directamente)
	SendToWorker(&jono)
} // executeRulesForPacket ejecuta las reglas para un paquete espec√≠fico
func executeRulesForPacket(wrapper PacketWrapper, packetKey string, kbs []*ast.KnowledgeBase, gID string) {
	log.Printf("[GID:%s] üöÄ Iniciando ejecuci√≥n de reglas para paquete %s (IMEI: %s)", gID, packetKey, wrapper.IMEI)

	// üÜï NUEVO SISTEMA: Iniciar captura de auditor√≠a ANTES de ejecutar reglas
	audit.StartCapture(wrapper.IMEI)
	defer audit.FinishCapture(wrapper.IMEI) // Guardar al finalizar

	dataCtx := ast.NewDataContext()
	dataCtx.Add("Jono", &wrapper)

	// Crear Property con sincronizaci√≥n via channels
	property := NewProperty(gID, context.Background())
	defer property.Close()

	log.Printf("[GID:%s] üìã Property creado para sincronizaci√≥n de eventos", gID)

	state := NewPersistentState(wrapper.IMEI)
	dataCtx.Add("state", state)
	dataCtx.Add("property", property)

	// üÜï NUEVO SISTEMA: ActionsHelper con snapshot completo del contexto para Audit()
	actionsObj := &actions.ActionsHelper{
		IMEI:              wrapper.IMEI,
		Speed:             wrapper.Speed,
		Latitude:          wrapper.Latitude,
		Longitude:         wrapper.Longitude,
		Altitude:          wrapper.Altitude,
		GSMSignalStrength: wrapper.GSMSignalStrength,
		Satellites:        wrapper.NumberOfSatellites,
		PositioningStatus: wrapper.PositioningStatus,
		EventCode:         wrapper.EventCode.Name,
		Datetime:          wrapper.Datetime,
	}
	dataCtx.Add("actions", actionsObj)

	eng := engine.NewGruleEngine()
	eng.MaxCycle = 100 // Reducir ciclos m√°ximos para detectar ciclos infinitos r√°pidamente

	// üéØ CAPTURAR TODAS las reglas del knowledge base (sin evaluar condiciones)
	// Las condiciones no se cumplen antes de Execute(), as√≠ que capturamos TODAS
	allRulesMap := make(map[string]int) // ruleName -> salience
	for _, kb := range kbs {
		for ruleName, ruleEntry := range kb.RuleEntries {
			allRulesMap[ruleName] = ruleEntry.Salience
			log.Printf("[GID:%s] üéØ Regla registrada para auditor√≠a: %s (salience=%d)", gID, ruleName, ruleEntry.Salience)
		}
	}

	for i, kb := range kbs {
		log.Printf("[GID:%s] üìã Ejecutando knowledge base %d/%d con %d reglas", gID, i+1, len(kbs), len(kb.RuleEntries))

		err := eng.Execute(dataCtx, kb)
		if err != nil {
			log.Printf("[GID:%s] ‚ö†Ô∏è  ERROR en paquete %s: %v", gID, packetKey, err)
			log.Printf("[GID:%s]    Estado del contexto cuando fall√≥:", gID)
			log.Printf("[GID:%s]    - Jono.PositioningStatus: %s", gID, wrapper.PositioningStatus)
			log.Printf("[GID:%s]    - state.JammerPositions: %d", gID, state.GetCounter("jammer_positions"))
			log.Printf("[GID:%s]    - state.JammerAvgSpeed90min: %d", gID, state.GetCounter("jammer_avg_speed_90min"))
			log.Printf("[GID:%s]    - state.JammerAvgGsm5: %d", gID, state.GetCounter("jammer_avg_gsm_last5"))
			log.Printf("[GID:%s]    - state.JammerAlertSent: %v", gID, state.IsAlertSent("jammer_real_mercury_2025"))
		} else {
			log.Printf("[GID:%s] ‚úÖ Knowledge base %d ejecutada sin errores", gID, i+1)

			// üîÑ SYNC: Actualizar wrapper flags desde Property state
			wrapper.DebugProcessed = property.GetDebugProcessed()
			wrapper.ResetProcessed = property.GetResetProcessed()
			wrapper.Cond1Processed = property.GetCond1Processed()
			wrapper.Cond2Processed = property.GetCond2Processed()
			wrapper.Cond3Processed = property.GetCond3Processed()
			wrapper.Cond4Processed = property.GetCond4Processed()
			wrapper.Cond5Processed = property.GetCond5Processed()
			// wrapper.BufferUpdated = property.GetBufferUpdated()  // Set by rule on Jono
			// wrapper.BufferHas10 = property.GetBufferHas10()      // Set by rule on Jono
			// wrapper.MetricsReady = property.GetMetricsReady()
			wrapper.CurrentlyInvalid = property.GetCurrentlyInvalid()
			wrapper.EvaluationSkipped = property.GetEvaluationSkipped()
			wrapper.AlertFired = property.GetAlertFired()

			log.Printf("[GID:%s]    Estado final del contexto:", gID)
			log.Printf("[GID:%s]    - state.JammerPositions: %d", gID, state.GetCounter("jammer_positions"))
			log.Printf("[GID:%s]    - state.JammerAvgSpeed90min: %d", gID, state.GetCounter("jammer_avg_speed_90min"))
			log.Printf("[GID:%s]    - state.JammerAvgGsm5: %d", gID, state.GetCounter("jammer_avg_gsm_last5"))
			log.Printf("[GID:%s]    - state.JammerAlertSent: %v", gID, state.IsAlertSent("jammer_real_mercury_2025"))

			// LOG DE FLAGS DESPU√âS DE EJECUTAR REGLAS - DESDE PROPERTY
			log.Printf("[GID:%s] üö® FLAGS DESPU√âS DE EJECUTAR REGLAS (desde Property):", gID)
			log.Printf("[GID:%s]    - property.Cond1Passed: %v", gID, property.GetCond1Passed())
			log.Printf("[GID:%s]    - property.Cond2Passed: %v", gID, property.GetCond2Passed())
			log.Printf("[GID:%s]    - property.Cond3Passed: %v", gID, property.GetCond3Passed())
			log.Printf("[GID:%s]    - property.Cond4Passed: %v", gID, property.GetCond4Passed())
			log.Printf("[GID:%s]    - property.Cond5Passed: %v", gID, property.GetCond5Passed())

			// Tambi√©n loggeamos desde Jono por compatibilidad (ahora usando property)
			log.Printf("[GID:%s]    - Jono.Cond1Passed: %v (via property)", gID, property.GetCond1Passed())
			log.Printf("[GID:%s]    - Jono.Cond2Passed: %v (via property)", gID, property.GetCond2Passed())
			log.Printf("[GID:%s]    - Jono.Cond3Passed: %v (via property)", gID, property.GetCond3Passed())
			log.Printf("[GID:%s]    - Jono.Cond4Passed: %v (via property)", gID, property.GetCond4Passed())
			log.Printf("[GID:%s]    - Jono.Cond5Passed: %v (via property)", gID, property.GetCond5Passed())

			log.Printf("[GID:%s]    - state.Cond2Checked: %v", gID, state.GetCond2Checked())
			log.Printf("[GID:%s]    - state.Cond3Checked: %v", gID, state.GetCond3Checked())
			log.Printf("[GID:%s]    - state.Cond4Checked: %v", gID, state.GetCond4Checked())
		}
	}

	// Persist wrapper flags to state for next packet
	if wrapper.BufferUpdated {
		state.SetCounter("last_buffer_updated", 1)
	} else {
		state.SetCounter("last_buffer_updated", 0)
	}
	if wrapper.BufferHas10 {
		state.SetCounter("last_buffer_has10", 1)
	} else {
		state.SetCounter("last_buffer_has10", 0)
	}
	if wrapper.MetricsReady {
		state.SetCounter("last_metrics_ready", 1)
	} else {
		state.SetCounter("last_metrics_ready", 0)
	}
	if wrapper.AlertFired {
		state.SetCounter("last_alert_fired", 1)
	} else {
		state.SetCounter("last_alert_fired", 0)
	}
	if wrapper.IsOfflineFor5Min {
		state.SetCounter("last_is_offline_for_5min", 1)
	} else {
		state.SetCounter("last_is_offline_for_5min", 0)
	}

	// üÜï NUEVO SISTEMA: La auditor√≠a se guarda autom√°ticamente en defer audit.FinishCapture()

	// üé¨ CAPTURAR "FRAMES DE PEL√çCULA" con buffer circular y contexto completo
	captureMovieFrames(wrapper.IMEI, wrapper, state, gID, allRulesMap)

	log.Printf("[GID:%s] üèÅ Finalizada ejecuci√≥n de reglas para paquete %s", gID, packetKey)
}

// captureMovieFrames captura el estado completo como "frames de pel√≠cula"
// Muestra la evoluci√≥n: buffer circular, m√©tricas, geofences, flags
// AHORA: 1 frame por ejecuci√≥n de KB, con componentes ejecutados
func captureMovieFrames(imei string, wrapper PacketWrapper, state *PersistentState, gID string, allRules map[string]int) {
	// Si no hay reglas ejecutadas, no guardar frame
	if len(allRules) == 0 {
		log.Printf("[GID:%s] üé¨ No hay reglas ejecutadas - no se guarda frame", gID)
		return
	}

	// Obtener buffer circular completo
	bufferEntries := GetBufferEntries(imei)

	// Usar LastValidDatetime del wrapper (calculado previamente)
	var lastValidDatetimeStr interface{} = nil
	if !wrapper.LastValidDatetime.IsZero() {
		lastValidDatetimeStr = wrapper.LastValidDatetime.Format(time.RFC3339)
	}

	// Construir snapshot del contexto completo
	contextSnapshot := map[string]interface{}{
		"buffer_circular": bufferEntries, // "Cuadritos de la pel√≠cula" - historial de posiciones
		"jammer_metrics": map[string]interface{}{
			"avg_speed_90min":  state.GetCounter("jammer_avg_speed_90min"),
			"avg_gsm_last5":    state.GetCounter("jammer_avg_gsm_last5"),
			"jammer_positions": state.GetCounter("jammer_positions"),
		},
		"geofence_checks": map[string]bool{
			"inside_taller":    state.IsInsideGroup("Taller", wrapper.Latitude, wrapper.Longitude),
			"inside_clientes":  state.IsInsideGroup("CLIENTES", wrapper.Latitude, wrapper.Longitude),
			"inside_resguardo": state.IsInsideGroup("Resguardo/Cedis/Puerto", wrapper.Latitude, wrapper.Longitude),
			"offline_5min":     state.IsOfflineFor(5),
		},
		"wrapper_flags": map[string]interface{}{
			"BufferUpdated":       wrapper.BufferUpdated,
			"BufferHas10":         wrapper.BufferHas10,
			"MetricsReady":        wrapper.MetricsReady,
			"CurrentlyInvalid":    wrapper.CurrentlyInvalid,
			"EvaluationSkipped":   wrapper.EvaluationSkipped,
			"AlertFired":          wrapper.AlertFired,
			"IsOfflineFor5Min":    wrapper.IsOfflineFor5Min,
			"last_valid_datetime": lastValidDatetimeStr,
		},
		"packet_current": map[string]interface{}{
			"Speed":             wrapper.Speed,
			"Latitude":          wrapper.Latitude,
			"Longitude":         wrapper.Longitude,
			"Altitude":          wrapper.Altitude,
			"GSMSignalStrength": wrapper.GSMSignalStrength,
			"Satellites":        wrapper.NumberOfSatellites,
			"PositioningStatus": wrapper.PositioningStatus,
			"Datetime":          wrapper.Datetime,
			"EventCode":         wrapper.EventCode,
		},
	}

	// Detectar componentes ejecutados bas√°ndose en flags del wrapper
	componentsExecuted := detectExecutedComponents(wrapper)
	componentDetails := map[string]interface{}{
		"buffer_updated":     wrapper.BufferUpdated,
		"buffer_size":        len(bufferEntries),
		"metrics_calculated": wrapper.MetricsReady,
		"evaluation_skipped": wrapper.EvaluationSkipped,
		"alert_triggered":    wrapper.AlertFired,
	}

	// Inferir en qu√© "escena de la pel√≠cula" estamos
	step := 0
	stage := "unknown"
	reason := "unknown"

	if wrapper.AlertFired {
		step = 4
		stage = "defcon4_alert"
		reason = "jammer_detected"
	} else if wrapper.Cond3Passed {
		step = 3
		stage = "defcon3_safe_zones"
		reason = "outside_safe_zones"
	} else if wrapper.Cond2Passed {
		step = 2
		stage = "defcon2_inhibition"
		reason = "inhibition_confirmed"
	} else if wrapper.MetricsReady {
		step = 2
		stage = "defcon2_metrics"
		reason = "metrics_calculated"
	} else if wrapper.Cond1Passed {
		step = 1
		stage = "defcon1_contact_lost"
		reason = "position_lost"
	} else if wrapper.Cond1Processed {
		step = 1
		stage = "defcon1_valid"
		reason = "position_valid"
	} else if wrapper.BufferUpdated {
		step = 0
		stage = "defcon0_surveillance"
		if wrapper.BufferHas10 {
			reason = "buffer_full"
		} else {
			reason = fmt.Sprintf("buffer_updating (%d/10)", len(bufferEntries))
		}
	} else {
		step = 0
		stage = "defcon0_initial"
		reason = "waiting_for_packet"
	}

	// Determinar evaluaci√≥n de geofence
	geofenceEval := "not_evaluated"
	if step >= 3 {
		if state.IsInsideGroup("Taller", wrapper.Latitude, wrapper.Longitude) {
			geofenceEval = "inside_taller"
		} else if state.IsInsideGroup("CLIENTES", wrapper.Latitude, wrapper.Longitude) {
			geofenceEval = "inside_clientes"
		} else if state.IsInsideGroup("Resguardo/Cedis/Puerto", wrapper.Latitude, wrapper.Longitude) {
			geofenceEval = "inside_resguardo"
		} else {
			geofenceEval = "outside_all"
		}
	}

	// CONSOLIDACI√ìN: 1 frame por ejecuci√≥n de KB
	// Si hay m√∫ltiples reglas, tomar el nombre principal de la regla
	var ruleName string
	var ruleID int64
	ruleName = "Jammer-Wargames-DEFCON" // Nombre principal de la regla
	ruleID = getRuleIDByName(ruleName)

	log.Printf("[GID:%s] üé¨ Frame consolidado: Rule='%s' (ID=%d), Components=%v, Step=%d, Stage=%s, Reason=%s, Buffer=%d/10",
		gID, ruleName, ruleID, componentsExecuted, step, stage, reason, len(bufferEntries))

	// Guardar UN SOLO frame consolidado
	err := audit.SaveProgressFrame(imei, ruleID, ruleName, componentsExecuted, componentDetails,
		step, stage, reason, len(bufferEntries), wrapper.MetricsReady, geofenceEval, contextSnapshot)

	if err != nil {
		log.Printf("[GID:%s] ‚ö†Ô∏è Error guardando frame consolidado: %v", gID, err)
	} else {
		log.Printf("[GID:%s]    ‚úÖ Frame consolidado guardado en DB", gID)
	}
}

// detectExecutedComponents determina qu√© componentes de la regla jammer_real se ejecutaron
func detectExecutedComponents(wrapper PacketWrapper) []string {
	var components []string

	// Componente 1: BufferUpdate - se ejecuta si BufferUpdated
	if wrapper.BufferUpdated {
		components = append(components, "BufferUpdate")
	}

	// Componente 2: CalculateMetrics - se ejecuta si MetricsReady (porque se calculan m√©tricas)
	if wrapper.MetricsReady {
		components = append(components, "CalculateMetrics")
	}

	// Componente 3: Detection - se ejecuta si AlertFired
	if wrapper.AlertFired {
		components = append(components, "Detection")
	}

	// Componente 4: SkipIfValid - se ejecuta si EvaluationSkipped
	if wrapper.EvaluationSkipped {
		components = append(components, "SkipIfValid")
	}

	return components
}

// getRuleIDByName obtiene el ID de una regla desde fleet_rules por nombre
func getRuleIDByName(ruleName string) int64 {
	return GetRuleIDByName(ruleName)
}

// Convierte strings vac√≠os "" a null en campos datetime para evitar parsing errors
