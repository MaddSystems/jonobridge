package engine

import (
	"database/sql"
	"encoding/json"
	"log"
	"math"
	"sync"
	"time"
)

// HistoryPoint stores a single data point for historical analysis (e.s., Jammer detection).
type HistoryPoint struct {
	Speed     int64     `json:"speed"`
	GSMSignal int64     `json:"gsm_signal"`
	Timestamp time.Time `json:"timestamp"`
}

type PersistentState struct {
	imei       string
	prevInside map[string]bool
	mutex      sync.RWMutex
	// Campos p√∫blicos para que Grule pueda modificarlos directamente y ver los cambios
	BotonPanicoExecuted     bool
	ExcesoVelocidadExecuted bool

	// === CONTADORES P√öBLICOS PARA JAMMER DETECTION ===
	// Grule modifica estos valores directamente, y los cambios se sincronizan con BD
	JammerPositions     int64 // Contador de posiciones inv√°lidas
	JammerAvgSpeed90min int64 // Velocidad promedio √∫ltimos 90 min
	JammerAvgGsm5       int64 // Se√±al GSM promedio √∫ltimos 5 puntos
	JammerAlertSent     bool  // Flag de alerta enviada

	// === PROPIEDADES DE TRACKING PARA EVITAR LOOPS ===
	JammerProcessed bool // Flag que indica si ya proces√≥ esta trama

	// === FLAGS DE CONDICIONES PARA AUDIT TRAIL ===
	// Estos flags marcan qu√© condici√≥n espec√≠fica se cumpli√≥ para auditor√≠a
	Cond2Checked bool // Cond2: Contador >= 10
	Cond3Checked bool // Cond3: Velocidad promedio >= 10
	Cond4Checked bool // Cond4: Se√±al GSM >= 9

	// === NUEVO CAMPO PARA EXPRESI√ìN 4 GPSgate ===
	lastValidPosition time.Time // √öltima posici√≥n v√°lida para calcular offline
}

// GetSnapshot returns a map of all relevant state variables for auditing
func (s *PersistentState) GetSnapshot() map[string]interface{} {
	s.mutex.RLock()
	defer s.mutex.RUnlock()

	return map[string]interface{}{
		"jammer_positions":       s.JammerPositions,
		"jammer_avg_speed_90min": s.JammerAvgSpeed90min,
		"jammer_avg_gsm_last5":   s.JammerAvgGsm5,
		"jammer_alert_sent":      s.JammerAlertSent,
		"cond2_checked":          s.Cond2Checked,
		"cond3_checked":          s.Cond3Checked,
		"cond4_checked":          s.Cond4Checked,
	}
}

var states = make(map[string]*PersistentState)
var statesMutex sync.RWMutex

func NewPersistentState(imei string) *PersistentState {
	statesMutex.Lock()
	if s, ok := states[imei]; ok {
		statesMutex.Unlock()
		// Reset executed rules para este nuevo packet
		s.mutex.Lock()
		s.BotonPanicoExecuted = false
		s.ExcesoVelocidadExecuted = false
		s.JammerProcessed = false
		s.Cond2Checked = false
		s.Cond3Checked = false
		s.Cond4Checked = false
		s.mutex.Unlock()
		return s
	}
	s := &PersistentState{
		imei:       imei,
		prevInside: make(map[string]bool),
	}
	states[imei] = s
	statesMutex.Unlock()
	return s
}

func (s *PersistentState) IsInsideCircle(lat, lon, clat, clon, radius float64) bool {
	// Haversine distance in meters
	const earthRadius = 6371000.0 // meters
	dLat := (clat - lat) * math.Pi / 180.0
	dLon := (clon - lon) * math.Pi / 180.0
	a := math.Sin(dLat/2)*math.Sin(dLat/2) +
		math.Cos(lat*math.Pi/180.0)*math.Cos(clat*math.Pi/180.0)*
			math.Sin(dLon/2)*math.Sin(dLon/2)
	c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))
	distance := earthRadius * c
	return distance <= radius
}

func (s *PersistentState) EnteredGeofence(id string, inside bool) bool {
	s.mutex.RLock()
	prev := s.prevInside[id]
	s.mutex.RUnlock()

	s.mutex.Lock()
	s.prevInside[id] = inside
	s.mutex.Unlock()

	return inside && !prev
}

// ============================================================================
// SISTEMA DE TEMPORIZACI√ìN EN GEOCERCAS (MySQL persistente)
// ============================================================================
// Estas funciones permiten reglas tipo:
// - "Veh√≠culo estacionado en zona de carga > 30 minutos ‚Üí alerta"
// - "Veh√≠culo en taller > 2 horas ‚Üí notificar mantenimiento"
// - "Veh√≠culo en zona prohibida > 2 horas ‚Üí corte autom√°tico"
//
// El estado se guarda en MySQL, por lo que sobrevive reinicios del servicio
// y funciona para flotas de cualquier tama√±o (probado con 800k+ veh√≠culos)
// ============================================================================

// SecondsInsideGeofence retorna cu√°ntos segundos lleva el veh√≠culo dentro de una geocerca
// Si currentlyInside = true y no hay registro ‚Üí guarda NOW() como entrada
// Si currentlyInside = false ‚Üí elimina el registro (sali√≥ de la geocerca)
func (s *PersistentState) SecondsInsideGeofence(id string, currentlyInside bool) float64 {
	key := "geo:" + id

	if currentlyInside {
		// Verificar si ya existe timestamp de entrada
		var entryTime sql.NullTime
		err := db.QueryRow(
			"SELECT value_time FROM vehicle_rule_state WHERE imei=? AND key_name=?",
			s.imei, key,
		).Scan(&entryTime)

		if err == sql.ErrNoRows || !entryTime.Valid {
			// Acaba de entrar ‚Üí guardar NOW()
			db.Exec(
				"INSERT INTO vehicle_rule_state (imei, key_name, value_time) VALUES(?, ?, NOW(6)) ON DUPLICATE KEY UPDATE value_time=NOW(6)",
				s.imei, key,
			)
			return 0
		}

		// Ya estaba dentro ‚Üí calcular tiempo transcurrido
		return time.Since(entryTime.Time).Seconds()
	}

	// Sale de la geocerca ‚Üí eliminar timer
	db.Exec("DELETE FROM vehicle_rule_state WHERE imei=? AND key_name=?", s.imei, key)
	return 0
}

// MinutesInsideGeofence versi√≥n en minutos (m√°s legible para reglas)
func (s *PersistentState) MinutesInsideGeofence(id string, currentlyInside bool) float64 {
	return s.SecondsInsideGeofence(id, currentlyInside) / 60.0
}

// HoursInsideGeofence versi√≥n en horas (para casos largos tipo taller, mantenimiento)
func (s *PersistentState) HoursInsideGeofence(id string, currentlyInside bool) float64 {
	return s.SecondsInsideGeofence(id, currentlyInside) / 3600.0
}

// ============================================================================
// SISTEMA DE FACTS (Alertas anti-spam)
// ============================================================================
// Evita enviar la misma alerta m√∫ltiples veces
// Ejemplo: "Veh√≠culo lleva +30 min estacionado" ‚Üí enviar solo UNA vez
// ============================================================================

// IsAlertSent verifica si una alerta espec√≠fica ya fue enviada para este veh√≠culo
func (s *PersistentState) IsAlertSent(alertID string) bool {
	// Cheque r√°pido en propiedad p√∫blica para jammer
	if alertID == "jammer_real_mercury_2025" {
		return s.JammerAlertSent
	}

	var exists int
	err := db.QueryRow(
		"SELECT 1 FROM vehicle_rule_state WHERE imei=? AND key_name=? LIMIT 1",
		s.imei, "alert:"+alertID,
	).Scan(&exists)
	return err == nil && exists == 1
}

// MarkAlertSent marca una alerta como enviada (evita spam) y retorna bool para que Grule detecte cambios
// La alerta quedar√° marcada hasta que se llame a ResetAlert o se limpie autom√°ticamente
func (s *PersistentState) MarkAlertSent(alertID string) bool {
	// Marcar en propiedad p√∫blica para jammer
	if alertID == "jammer_real_mercury_2025" {
		s.JammerAlertSent = true
	}

	_, err := db.Exec(
		"INSERT INTO vehicle_rule_state (imei, key_name, value_int, updated_at) VALUES(?, ?, 1, NOW(6)) ON DUPLICATE KEY UPDATE updated_at=NOW(6)",
		s.imei, "alert:"+alertID,
	)
	return err == nil
}

// ResetAlert elimina el flag de alerta enviada (permite volver a alertar) y retorna bool para que Grule detecte cambios
// T√≠picamente se usa en reglas de "reset" al salir de geocerca
func (s *PersistentState) ResetAlert(alertID string) bool {
	// Resetear en propiedad p√∫blica para jammer
	if alertID == "jammer_real_mercury_2025" {
		s.JammerAlertSent = false
	}

	_, err := db.Exec("DELETE FROM vehicle_rule_state WHERE imei=? AND key_name=?", s.imei, "alert:"+alertID)
	return err == nil
}

// ============================================================================
// SISTEMA DE CONTADORES
// ============================================================================
// Para contar eventos: frenadas bruscas, excesos de velocidad, etc.
// Ejemplo: "Si frena bruscamente 3 veces en 1 hora ‚Üí notificar supervisor"
// ============================================================================

// IncCounter incrementa un contador y retorna el nuevo valor
// √ötil para reglas tipo: "3 frenadas bruscas ‚Üí alerta"
func (s *PersistentState) IncCounter(name string) int64 {
	// Contadores p√∫blicos que Grule puede ver cambiar
	switch name {
	case "jammer_positions":
		s.JammerPositions++
		return s.JammerPositions
	case "jammer_avg_speed_90min":
		s.JammerAvgSpeed90min++
		return s.JammerAvgSpeed90min
	case "jammer_avg_gsm_last5":
		s.JammerAvgGsm5++
		return s.JammerAvgGsm5
	}

	// Para otros contadores, usar BD
	key := name
	var count int64

	// Obtener valor actual
	err := db.QueryRow(
		"SELECT IFNULL(value_int, 0) FROM vehicle_rule_state WHERE imei=? AND key_name=?",
		s.imei, key,
	).Scan(&count)
	if err != nil && err != sql.ErrNoRows {
		log.Printf("‚ùå DB Error getting counter '%s' for IMEI %s: %v", name, s.imei, err)
	}

	count++

	// Actualizar
	_, err = db.Exec(
		"INSERT INTO vehicle_rule_state (imei, key_name, value_int) VALUES(?, ?, ?) ON DUPLICATE KEY UPDATE value_int=?",
		s.imei, key, count, count,
	)
	if err != nil {
		log.Printf("‚ùå DB Error setting counter '%s' for IMEI %s: %v", name, s.imei, err)
	}

	return count
}

// GetCounter obtiene el valor actual de un contador (sin incrementarlo)
// Primero intenta desde la propiedad p√∫blica (para Jammer), luego desde BD
func (s *PersistentState) GetCounter(name string) int64 {
	// Contadores p√∫blicos que Grule puede ver cambiar
	switch name {
	case "jammer_positions":
		return s.JammerPositions
	case "jammer_avg_speed_90min":
		return s.JammerAvgSpeed90min
	case "jammer_avg_gsm_last5":
		return s.JammerAvgGsm5
	}

	// Para otros contadores, usar BD
	var count int64
	err := db.QueryRow(
		"SELECT IFNULL(value_int, 0) FROM vehicle_rule_state WHERE imei=? AND key_name=?",
		s.imei, name,
	).Scan(&count)
	if err != nil && err != sql.ErrNoRows {
		log.Printf("‚ùå DB Error getting counter '%s' for IMEI %s: %v", name, s.imei, err)
	}
	return count
}

// ResetCounter pone un contador en cero y retorna bool para que Grule detecte cambios
func (s *PersistentState) ResetCounter(name string) bool {
	// Contadores p√∫blicos
	switch name {
	case "jammer_positions":
		s.JammerPositions = 0
		return true
	case "jammer_avg_speed_90min":
		s.JammerAvgSpeed90min = 0
		return true
	case "jammer_avg_gsm_last5":
		s.JammerAvgGsm5 = 0
		return true
	}

	_, err := db.Exec("DELETE FROM vehicle_rule_state WHERE imei=? AND key_name=?", s.imei, name)
	if err != nil {
		log.Printf("‚ùå DB Error resetting counter '%s' for IMEI %s: %v", name, s.imei, err)
		return false
	}
	return true
}

// SetCounter establece un valor espec√≠fico para un contador y retorna bool para que Grule detecte cambios
func (s *PersistentState) SetCounter(name string, value int64) bool {
	// Contadores p√∫blicos
	switch name {
	case "jammer_positions":
		s.JammerPositions = value
		return true
	case "jammer_avg_speed_90min":
		s.JammerAvgSpeed90min = value
		return true
	case "jammer_avg_gsm_last5":
		s.JammerAvgGsm5 = value
		return true
	}

	_, err := db.Exec(
		"INSERT INTO vehicle_rule_state (imei, key_name, value_int) VALUES(?, ?, ?) ON DUPLICATE KEY UPDATE value_int=?",
		s.imei, name, value, value,
	)
	if err != nil {
		log.Printf("‚ùå DB Error setting counter '%s' for IMEI %s: %v", name, s.imei, err)
		return false
	}
	return true
}

// GetBotonPanicoExecuted devuelve si BotonPanico ya se ejecut√≥
func (s *PersistentState) GetBotonPanicoExecuted() bool {
	s.mutex.RLock()
	defer s.mutex.RUnlock()
	log.Printf("üîç GetBotonPanicoExecuted() = %v", s.BotonPanicoExecuted)
	return s.BotonPanicoExecuted
}

// SetBotonPanicoExecuted marca BotonPanico como ejecutado
func (s *PersistentState) SetBotonPanicoExecuted(executed bool) {
	s.mutex.Lock()
	defer s.mutex.Unlock()
	s.BotonPanicoExecuted = executed
	log.Printf("‚úÖ SetBotonPanicoExecuted(%v)", executed)
}

// IsInsideGroup verifica si el veh√≠culo est√° dentro de CUALQUIERA de las geocercas de un grupo
// Retorna true si el veh√≠culo est√° dentro de al menos una geocerca del grupo
// Nota: Requiere que se pase la latitud y longitud actual del veh√≠culo
func (s *PersistentState) IsInsideGroup(groupName string, latitude, longitude float64) bool {
	if db == nil {
		log.Printf("‚ùå Database no inicializada para IsInsideGroup")
		return false
	}

	// Obtener todas las geocercas del grupo
	query := `
		SELECT s.id, s.name, s.shapeType, s.centerLat, s.centerLon, s.radius,
		       s.boundingBoxMinX, s.boundingBoxMaxX, s.boundingBoxMinY, s.boundingBoxMaxY
		FROM geofences.geofences s
		JOIN geofences.geofence_group_mapping m ON s.id = m.geofence_id
		JOIN geofences.geofence_groups gg ON m.group_id = gg.id
		WHERE gg.name = ?
		ORDER BY s.id
	`

	rows, err := db.Query(query, groupName)
	if err != nil {
		log.Printf("‚ùå Error consultando geocercas del grupo %s: %v", groupName, err)
		return false
	}
	defer rows.Close()

	// Verificar si est√° dentro de cualquiera de las geocercas
	for rows.Next() {
		var (
			id                           int
			name                         string
			shapeType                    string
			centerLat, centerLon, radius sql.NullFloat64
			minX, maxX, minY, maxY       sql.NullFloat64
		)

		if err := rows.Scan(&id, &name, &shapeType, &centerLat, &centerLon, &radius,
			&minX, &maxX, &minY, &maxY); err != nil {
			log.Printf("‚ö†Ô∏è  Error escaneando geocerca: %v", err)
			continue
		}

		// Verificar si es un c√≠rculo
		if shapeType == "Circle" && centerLat.Valid && centerLon.Valid && radius.Valid {
			if s.IsInsideCircle(latitude, longitude, centerLat.Float64, centerLon.Float64, radius.Float64) {
				log.Printf("‚úÖ Veh√≠culo %s est√° dentro de c√≠rculo '%s' en grupo '%s'", s.imei, name, groupName)
				return true
			}
		}

		// Verificar si es un pol√≠gono (aproximaci√≥n con bounding box)
		if shapeType == "Polygon" && minX.Valid && maxX.Valid && minY.Valid && maxY.Valid {
			if latitude >= minY.Float64 && latitude <= maxY.Float64 &&
				longitude >= minX.Float64 && longitude <= maxX.Float64 {
				log.Printf("‚úÖ Veh√≠culo %s est√° dentro de pol√≠gono '%s' en grupo '%s'", s.imei, name, groupName)
				return true
			}
		}
	}

	if err = rows.Err(); err != nil {
		log.Printf("‚ùå Error iterando geocercas: %v", err)
		return false
	}

	log.Printf("‚ùå Veh√≠culo %s NO est√° dentro de ninguna geocerca del grupo '%s'", s.imei, groupName)
	return false
}

// UpdateJammerHistoryExact replica la l√≥gica del script de GPSGate.
// Acumula un historial de hasta 10 puntos. Si la trama actual es inv√°lida y el historial est√° lleno,
// calcula los promedios de velocidad (√∫ltimos 90 min) y GSM (√∫ltimos 5 puntos) y los guarda en contadores.
func (s *PersistentState) UpdateJammerHistoryExact(speed int, gsmSignal int, datetime time.Time, positioningStatus string) bool {
	const historyKey = "history:jammer_points"
	const maxHistorySize = 10
	const historyDuration = -90 * time.Minute

	// Incrementar el contador de posiciones con posible jammer
	s.IncCounter("jammer_positions")

	// 1. Cargar historial
	var historyText sql.NullString
	err := db.QueryRow("SELECT value_text FROM vehicle_rule_state WHERE imei = ? AND key_name = ?", s.imei, historyKey).Scan(&historyText)
	if err != nil && err != sql.ErrNoRows {
		log.Printf("‚ùå ERROR fetching jammer history for IMEI %s: %v", s.imei, err)
		return false
	}

	var history []HistoryPoint
	if historyText.Valid && historyText.String != "" {
		if err := json.Unmarshal([]byte(historyText.String), &history); err != nil {
			log.Printf("‚ö†Ô∏è  WARN parsing jammer history for IMEI %s: %v", s.imei, err)
		}
	}

	// 2. A√±adir punto actual y mantener el historial en 10 puntos
	newPoint := HistoryPoint{Speed: int64(speed), GSMSignal: int64(gsmSignal), Timestamp: datetime}
	history = append(history, newPoint)
	if len(history) > maxHistorySize {
		history = history[1:] // Mantener solo los √∫ltimos 10
	}

	// 3. Si la posici√≥n es v√°lida o no tenemos suficientes datos, solo guardamos el historial
	if positioningStatus == "A" || len(history) < maxHistorySize {
		historyJSON, _ := json.Marshal(history)
		db.Exec("INSERT INTO vehicle_rule_state (imei, key_name, value_text) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE value_text = ?",
			s.imei, historyKey, string(historyJSON), string(historyJSON))
		return true
	}

	// 4. La posici√≥n es INV√ÅLIDA y tenemos 10 puntos. Calcular promedios.
	cutoffTime := time.Now().Add(historyDuration)
	var recentHistory []HistoryPoint
	for _, p := range history {
		if p.Timestamp.After(cutoffTime) {
			recentHistory = append(recentHistory, p)
		}
	}

	if len(recentHistory) == 0 {
		s.ResetCounter("jammer_avg_speed_90min")
		s.ResetCounter("jammer_avg_gsm_last5")
		db.Exec("DELETE FROM vehicle_rule_state WHERE imei = ? AND key_name = ?", s.imei, historyKey)
		return true
	}

	// Calcular promedio de velocidad (90 min)
	var totalSpeed int64
	for _, p := range recentHistory {
		totalSpeed += p.Speed
	}
	avgSpeed := totalSpeed / int64(len(recentHistory))

	// Calcular promedio de GSM (√∫ltimos 5 puntos del historial total)
	var totalGsm int64
	gsmPointsToConsider := 5
	if len(history) < gsmPointsToConsider {
		gsmPointsToConsider = len(history)
	}
	lastGsmPoints := history[len(history)-gsmPointsToConsider:]
	for _, p := range lastGsmPoints {
		totalGsm += p.GSMSignal
	}
	avgGsm := totalGsm / int64(len(lastGsmPoints))

	// 5. Actualizar contadores
	s.SetCounter("jammer_avg_speed_90min", avgSpeed)
	s.SetCounter("jammer_avg_gsm_last5", avgGsm)
	log.Printf("‚úÖ Jammer averages calculated for %s: AvgSpeed=%d, AvgGSM=%d", s.imei, avgSpeed, avgGsm)

	// 6. Guardar historial
	historyJSON, _ := json.Marshal(history)
	db.Exec("INSERT INTO vehicle_rule_state (imei, key_name, value_text) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE value_text = ?",
		s.imei, historyKey, string(historyJSON), string(historyJSON))

	return true
}

// ============================================================================
// M√âTODOS THREAD-SAFE PARA FLAGS DE CONDICIONES (Cond2Checked, Cond3Checked, Cond4Checked)
// ============================================================================

// GetCond2Checked obtiene el valor de Cond2Checked de forma thread-safe
func (s *PersistentState) GetCond2Checked() bool {
	s.mutex.RLock()
	defer s.mutex.RUnlock()
	return s.Cond2Checked
}

// SetCond2Checked establece el valor de Cond2Checked de forma thread-safe
func (s *PersistentState) SetCond2Checked(value bool) {
	s.mutex.Lock()
	defer s.mutex.Unlock()
	s.Cond2Checked = value
}

// GetCond3Checked obtiene el valor de Cond3Checked de forma thread-safe
func (s *PersistentState) GetCond3Checked() bool {
	s.mutex.RLock()
	defer s.mutex.RUnlock()
	return s.Cond3Checked
}

// SetCond3Checked establece el valor de Cond3Checked de forma thread-safe
func (s *PersistentState) SetCond3Checked(value bool) {
	s.mutex.Lock()
	defer s.mutex.Unlock()
	s.Cond3Checked = value
}

// GetCond4Checked obtiene el valor de Cond4Checked de forma thread-safe
func (s *PersistentState) GetCond4Checked() bool {
	s.mutex.RLock()
	defer s.mutex.RUnlock()
	return s.Cond4Checked
}

// SetCond4Checked establece el valor de Cond4Checked de forma thread-safe
func (s *PersistentState) SetCond4Checked(value bool) {
	s.mutex.Lock()
	defer s.mutex.Unlock()
	s.Cond4Checked = value
}

// ============================================================================
// FUNCIONES PARA SISTEMA DE BUFFERS CIRCULARES (R√âPLICA GPSgate)
// ============================================================================

// UpdateMemoryBuffer - REPLICA EXACTA l√≠neas 60-69 GPSgate
// CR√çTICO: Se llama SIEMPRE, independiente de si va a evaluar
func (s *PersistentState) UpdateMemoryBuffer(speed int64, gsmSignal int64, datetime time.Time,
	posStatus string, lat, lon float64) bool {
	// SIEMPRE actualiza buffer (r√©plica GPSgate l√≠neas 60-69)
	hasExactly10 := AddToBuffer(s.imei, speed, gsmSignal, datetime, posStatus, lat, lon)

	log.Printf("üß† [%s] Buffer SIEMPRE actualizado: Size=%d/10, Has10=%v, Status='%s'",
		s.imei, GetBufferSize(s.imei), hasExactly10, posStatus)

	return hasExactly10 // Retorna "doit" como GPSgate l√≠nea 65
}

// CalculateJammerMetricsIfReady - SOLO si inv√°lida + 10 posiciones
func (s *PersistentState) CalculateJammerMetricsIfReady(currentlyInvalid bool) bool {
	// CR√çTICO: Solo calcular si ambas condiciones (r√©plica l√≠neas 82+84)
	if !currentlyInvalid {
		log.Printf("üîç [%s] Posici√≥n V√ÅLIDA - omitir evaluaci√≥n (r√©plica GPSgate l√≠nea 115)", s.imei)
		return false
	}

	if !HasExactly10Positions(s.imei) {
		log.Printf("üîç [%s] Buffer incompleto (%d/10) - omitir evaluaci√≥n (r√©plica doit=false)",
			s.imei, GetBufferSize(s.imei))
		return false
	}

	// Ambas condiciones OK: calcular m√©tricas (r√©plica l√≠neas 88-106)
	avgSpeed90 := GetAverageSpeed90Min(s.imei)
	avgGSM5 := GetAverageGSMLast5(s.imei)

	// Guardar para que reglas las lean
	s.SetCounter("jammer_avg_speed_90min", int64(avgSpeed90))
	s.SetCounter("jammer_avg_gsm_last5", int64(avgGSM5))

	log.Printf("üìä [%s] M√©tricas calculadas: AvgSpeed90=%.1f, AvgGSM5=%.1f",
		s.imei, avgSpeed90, avgGSM5)

	return true
}

// IsOfflineFor - Verifica si dispositivo est√° offline por X minutos
// NECESARIO para Expresi√≥n 4 del sistema GPSgate
func (s *PersistentState) IsOfflineFor(minutes int) bool {
	s.mutex.RLock()
	defer s.mutex.RUnlock()

	if s.lastValidPosition.IsZero() {
		return false // Sin posici√≥n previa v√°lida
	}

	elapsed := time.Since(s.lastValidPosition).Minutes()
	isOffline := elapsed >= float64(minutes)

	if isOffline {
		log.Printf("‚è∞ [%s] Offline por %.1f minutos (umbral: %d min)", s.imei, elapsed, minutes)
	}

	return isOffline
}

// GetBufferSize - Obtiene tama√±o actual del buffer para un IMEI
func (s *PersistentState) GetBufferSize(imei string) int {
	return GetBufferSize(imei) // Llamada a funci√≥n global de memory_buffer.go
}
