package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strconv"
	"time"

	"github.com/jonobridge/grule-integrator/engine"
	"github.com/jonobridge/grule-integrator/engine/audit"
	mqtt "github.com/eclipse/paho.mqtt.golang"
)

func main() {
	log.SetFlags(log.LstdFlags | log.Lshortfile)
	log.Println("=== Iniciando Grule Engine con Universal Audit System ===")

	auditEnabled := os.Getenv("GRULE_AUDIT_ENABLED")
	auditLevel := os.Getenv("GRULE_AUDIT_LEVEL")
	log.Printf("GRULE_AUDIT_ENABLED: %s, GRULE_AUDIT_LEVEL: %s", auditEnabled, auditLevel)

	// Inicializar motor (MySQL + reglas)
	engine.Initialize()
	log.Println("‚úì Engine inicializado correctamente")

	// Inicializar auditor√≠a con la conexi√≥n MySQL
	if auditEnabled == "Y" {
		db := engine.GetDB()
		if db != nil {
			audit.InitDB(db)
			log.Printf("‚úì Audit layer initialized (level: %s)", auditLevel)
		} else {
			log.Println("‚ö†Ô∏è  Could not initialize audit: database connection not available")
		}
	}

	// Configurar cliente MQTT
	broker := os.Getenv("MQTT_BROKER_HOST")
	if broker == "" {
		log.Println("‚ùå MQTT_BROKER_HOST no definido, usando localhost")
		broker = "localhost"
	}

	opts := mqtt.NewClientOptions()
	opts.AddBroker("tcp://" + broker + ":1883")
	opts.SetClientID("GRULE_ENGINE_UNIVERSAL_" + os.Getenv("HOSTNAME") + "_" + fmt.Sprint(time.Now().UnixNano()%1e6))
	opts.SetAutoReconnect(true)
	opts.SetKeepAlive(60 * time.Second)
	opts.SetDefaultPublishHandler(func(_ mqtt.Client, msg mqtt.Message) {
		// ProcessJonoMessage env√≠a al worker pool
		engine.ProcessJonoMessage(string(msg.Payload()))
	})

	mqttClient := mqtt.NewClient(opts)
	log.Printf("üì° Conectando a MQTT broker: %s", broker)
	
	for {
		if token := mqttClient.Connect(); token.Wait() && token.Error() == nil {
			log.Println("‚úÖ Grule Engine conectado a MQTT")
			break
		}
		log.Println("‚ö†Ô∏è  Reintentando conexi√≥n MQTT en 5 segundos...")
		time.Sleep(5 * time.Second)
	}

	mqttClient.Subscribe("tracker/jonoprotocol", 1, nil)
	log.Println("‚úÖ Grule Engine suscrito a tracker/jonoprotocol")

	// API REST
	http.HandleFunc("/api/audit/summary", handleAuditSummary)
	http.HandleFunc("/api/audit/details", handleAuditDetails)
	http.HandleFunc("/api/health", handleHealth)

	port := os.Getenv("API_PORT")
	if port == "" {
		port = "8080"
	}

	log.Printf("‚úì API REST escuchando en puerto %s", port)
	log.Println("=== Sistema Universal Listo ===")
	log.Println("üì° MQTT: Procesando paquetes GPS en tiempo real")
	log.Println("üîç Audit: Capturando ejecuciones sin hardcoding")
	log.Println("üåê API: Endpoints /api/audit/summary y /api/audit/details")

	// Iniciar servidor HTTP (bloqueante)
	go func() {
		if err := http.ListenAndServe(":"+port, nil); err != nil {
			log.Fatalf("Error iniciando servidor HTTP: %v", err)
		}
	}()

	// Mantener el proceso vivo
	select {}
}

func handleAuditSummary(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	limit := 100
	if limitStr := r.URL.Query().Get("limit"); limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil {
			limit = l
		}
	}

	summaries, err := audit.GetIMEISummaries(limit)
	if err != nil {
		log.Printf("Error obteniendo summary: %v", err)
		http.Error(w, fmt.Sprintf("Error: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"success": true,
		"count":   len(summaries),
		"data":    summaries,
	})
}

func handleAuditDetails(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	imei := r.URL.Query().Get("imei")
	if imei == "" {
		http.Error(w, "IMEI parameter required", http.StatusBadRequest)
		return
	}

	limit := 100
	if limitStr := r.URL.Query().Get("limit"); limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil {
			limit = l
		}
	}

	details, err := audit.GetAlertDetails(imei, limit)
	if err != nil {
		log.Printf("Error obteniendo details para IMEI %s: %v", imei, err)
		http.Error(w, fmt.Sprintf("Error: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"success": true,
		"imei":    imei,
		"count":   len(details),
		"data":    details,
	})
}

func handleHealth(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"status":    "healthy",
		"timestamp": time.Now().Format(time.RFC3339),
		"service":   "grule-engine-universal",
	})
}
